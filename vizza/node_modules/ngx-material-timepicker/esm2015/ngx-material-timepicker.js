import { Injectable, Component, EventEmitter, HostListener, Input, Output, Pipe, ElementRef, ViewChild, Directive, forwardRef, Inject, Optional, NgModule } from '@angular/core';
import { BehaviorSubject, Subject, merge } from 'rxjs';
import * as moment from 'moment';
import { utc } from 'moment';
import { animate, style, transition, trigger } from '@angular/animations';
import { filter } from 'rxjs/operators';
import { DomSanitizer } from '@angular/platform-browser';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DOCUMENT, CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const TimePeriod = {
    AM: 'AM',
    PM: 'PM',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const TimeFormat = {
    TWELVE: 'hh:mm a',
    TWENTY_FOUR: 'HH:mm',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const moment$1 = moment;
const DEFAULT_HOUR = {
    time: 12,
    angle: 360
};
const DEFAULT_MINUTE = {
    time: '00',
    angle: 360
};
class NgxMaterialTimepickerService {
    constructor() {
        this.hourSubject = new BehaviorSubject(DEFAULT_HOUR);
        this.minuteSubject = new BehaviorSubject(DEFAULT_MINUTE);
        this.periodSubject = new BehaviorSubject(TimePeriod.AM);
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    set hour(hour) {
        this.hourSubject.next(hour);
    }
    /**
     * @return {?}
     */
    get selectedHour() {
        return this.hourSubject.asObservable();
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    set minute(minute) {
        this.minuteSubject.next(minute);
    }
    /**
     * @return {?}
     */
    get selectedMinute() {
        return this.minuteSubject.asObservable();
    }
    /**
     * @param {?} period
     * @return {?}
     */
    set period(period) {
        this.periodSubject.next(period);
    }
    /**
     * @return {?}
     */
    get selectedPeriod() {
        return this.periodSubject.asObservable();
    }
    /**
     * @return {?}
     */
    get fullTime() {
        const /** @type {?} */ hour = this.hourSubject.getValue().time;
        const /** @type {?} */ minute = this.minuteSubject.getValue().time;
        const /** @type {?} */ period = this.periodSubject.getValue();
        return `${hour}:${minute} ${period}`;
    }
    /**
     * @param {?} time
     * @return {?}
     */
    set defaultTime(time) {
        const /** @type {?} */ defaultTime = moment$1(time, TimeFormat.TWENTY_FOUR).toDate();
        if (moment$1(defaultTime).isValid()) {
            this.hour = Object.assign({}, DEFAULT_HOUR, { time: defaultTime.getHours() });
            this.minute = Object.assign({}, DEFAULT_MINUTE, { time: defaultTime.getMinutes() === 0 ? '00' : defaultTime.getMinutes() });
            this.period = /** @type {?} */ (time.substr(time.length - 2).toUpperCase());
        }
    }
}
NgxMaterialTimepickerService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxMaterialTimepickerService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const TimeUnit = {
    HOUR: 0,
    MINUTE: 1,
};
TimeUnit[TimeUnit.HOUR] = "HOUR";
TimeUnit[TimeUnit.MINUTE] = "MINUTE";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerEventService {
    constructor() {
        this.backdropClickSubject = new Subject();
        this.keydownEventSubject = new Subject();
    }
    /**
     * @return {?}
     */
    get backdropClick() {
        return this.backdropClickSubject.asObservable();
    }
    /**
     * @return {?}
     */
    get keydownEvent() {
        return this.keydownEventSubject.asObservable();
    }
}
NgxMaterialTimepickerEventService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxMaterialTimepickerEventService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
const AnimationState = {
    ENTER: 'enter',
    LEAVE: 'leave',
};
const ESCAPE = 27;
class NgxMaterialTimepickerComponent {
    /**
     * @param {?} timepickerService
     * @param {?} eventService
     */
    constructor(timepickerService, eventService) {
        this.timepickerService = timepickerService;
        this.eventService = eventService;
        this.timePeriod = TimePeriod;
        this.timeUnit = TimeUnit;
        this.activeTimeUnit = TimeUnit.HOUR;
        this.isOpened = false;
        this.subscriptions = [];
        this.isEsc = true;
        this.timeSet = new EventEmitter();
        this.subscriptions.push(merge(this.eventService.backdropClick, this.eventService.keydownEvent.pipe(filter(e => e.keyCode === ESCAPE && this.isEsc)))
            .subscribe(() => this.close()));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.timepickerService.selectedHour.subscribe(hour => this.selectedHour = hour));
        this.subscriptions.push(this.timepickerService.selectedMinute.subscribe(minute => this.selectedMinute = minute));
        this.subscriptions.push(this.timepickerService.selectedPeriod.subscribe(period => this.selectedPeriod = period));
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    onHourChange(hour) {
        this.timepickerService.hour = hour;
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    onMinuteChange(minute) {
        this.timepickerService.minute = minute;
    }
    /**
     * @param {?} period
     * @return {?}
     */
    changePeriod(period) {
        this.timepickerService.period = period;
    }
    /**
     * @param {?} unit
     * @return {?}
     */
    changeTimeUnit(unit) {
        this.activeTimeUnit = unit;
    }
    /**
     * @return {?}
     */
    setTime() {
        this.timeSet.next(this.timepickerService.fullTime);
        this.close();
    }
    /**
     * @param {?} time
     * @return {?}
     */
    setDefaultTime(time) {
        this.timepickerService.defaultTime = time;
    }
    /**
     * @return {?}
     */
    open() {
        this.isOpened = true;
        this.animationState = AnimationState.ENTER;
    }
    /**
     * @return {?}
     */
    close() {
        this.animationState = AnimationState.LEAVE;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    animationDone(event) {
        if (event.phaseName === 'done' && event.toState === AnimationState.LEAVE) {
            this.isOpened = false;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeydown(e) {
        this.eventService.keydownEventSubject.next(e);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
}
NgxMaterialTimepickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker',
                template: `<div class="timepicker-backdrop-overlay" *ngIf="isOpened" overlay></div>
<div class="timepicker-overlay" *ngIf="isOpened">
    <div class="timepicker" [@timepicker]="animationState" (@timepicker.done)="animationDone($event)" tabindex="0"
         focusAnchor>
        <header class="timepicker__header">
            <div class="timepicker-dial">
                <div class="timepicker-dial__time">
				<span class="timepicker-dial__item"
                      [ngClass]="{'timepicker-dial__item_active': activeTimeUnit === timeUnit.HOUR}"
                      (click)="changeTimeUnit(timeUnit.HOUR)">
					{{selectedHour?.time | timeFormatter: timeUnit.HOUR}}</span>:<span
                    class="timepicker-dial__item"
                    [ngClass]="{'timepicker-dial__item_active': activeTimeUnit === timeUnit.MINUTE}"
                    (click)="changeTimeUnit(timeUnit.MINUTE)">{{selectedMinute?.time | timeFormatter: timeUnit.MINUTE}}</span>
                </div>
                <div class="timepicker-dial__period">
			<span class="timepicker-dial__item"
                  [ngClass]="{'timepicker-dial__item_active': selectedPeriod === timePeriod.AM}"
                  (click)="changePeriod(timePeriod.AM)">AM</span>
                    <span class="timepicker-dial__item"
                          [ngClass]="{'timepicker-dial__item_active': selectedPeriod === timePeriod.PM}"
                          (click)="changePeriod(timePeriod.PM)">PM</span>
                </div>
            </div>
        </header>
        <div class="timepicker__main-content">
            <div class="timepicker__body" [ngSwitch]="activeTimeUnit">
                <ngx-material-timepicker-hours-face *ngSwitchCase="timeUnit.HOUR"
                                                    (hourChange)="onHourChange($event)"
                                                    [selectedHour]="selectedHour"
                                                    (hourSelected)="activeTimeUnit = timeUnit.MINUTE"></ngx-material-timepicker-hours-face>
                <ngx-material-timepicker-minutes-face *ngSwitchCase="timeUnit.MINUTE"
                                                      [selectedMinute]="selectedMinute"
                                                      (minuteChange)="onMinuteChange($event)"></ngx-material-timepicker-minutes-face>
            </div>
            <div class="timepicker__actions">
                <div (click)="close()">
                    <ng-container *ngTemplateOutlet="cancelBtnTmpl ? cancelBtnTmpl : cancelBtnDefault"></ng-container>
                </div>
                <div (click)="setTime()">
                    <ng-container
                        *ngTemplateOutlet="confirmBtnTmpl ? confirmBtnTmpl : confirmBtnDefault"></ng-container>
                </div>
            </div>
        </div>
    </div>
</div>
<ng-template #cancelBtnDefault>
    <ngx-material-timepicker-button>Cancel</ngx-material-timepicker-button>
</ng-template>
<ng-template #confirmBtnDefault>
    <ngx-material-timepicker-button>Ok</ngx-material-timepicker-button>
</ng-template>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-backdrop-overlay{position:fixed;top:0;bottom:0;right:0;left:0;background-color:rgba(0,0,0,.3);z-index:999;pointer-events:auto}.timepicker-overlay{position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:999;pointer-events:none}.timepicker{width:300px;border-radius:2px;-webkit-box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;box-shadow:rgba(0,0,0,.25) 0 14px 45px,rgba(0,0,0,.22) 0 10px 18px;outline:0;position:static;z-index:999;pointer-events:auto}.timepicker__header{background-color:#00bfff;padding:15px 30px}.timepicker__body{background-color:#fff;padding:15px 5px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__actions{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;padding:15px;background-color:#fff}.timepicker-dial{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;-webkit-tap-highlight-color:transparent}.timepicker-dial__time{line-height:normal;font-size:50px;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__period{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;margin-left:10px;font-size:18px;font-weight:500;font-family:Roboto,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.timepicker-dial__item{cursor:pointer;color:rgba(255,255,255,.5);font-family:Roboto,sans-serif}.timepicker-dial__item_active{color:#fff}@media (max-width:1023px) and (orientation:landscape){.timepicker{display:-webkit-box;display:-ms-flexbox;display:flex;width:515px}.timepicker__header{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.timepicker__main-content{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;width:100%}.timepicker__actions{padding:5px;margin-top:-1px}.timepicker-dial{-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.timepicker-dial__period{margin-left:0}}`],
                animations: [
                    trigger('timepicker', [
                        transition(`* => ${AnimationState.ENTER}`, [
                            style({ transform: 'translateY(-30%)' }),
                            animate('0.2s ease-out', style({ transform: 'translateY(0)' }))
                        ]),
                        transition(`${AnimationState.ENTER} => ${AnimationState.LEAVE}`, [
                            style({ transform: 'translateY(0)', opacity: 1 }),
                            animate('0.2s ease-out', style({ transform: 'translateY(-30%)', opacity: 0 }))
                        ])
                    ])
                ],
                providers: [NgxMaterialTimepickerService]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerComponent.ctorParameters = () => [
    { type: NgxMaterialTimepickerService, },
    { type: NgxMaterialTimepickerEventService, },
];
NgxMaterialTimepickerComponent.propDecorators = {
    "cancelBtnTmpl": [{ type: Input },],
    "confirmBtnTmpl": [{ type: Input },],
    "isEsc": [{ type: Input, args: ['ESC',] },],
    "timeSet": [{ type: Output },],
    "onKeydown": [{ type: HostListener, args: ['keydown', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class StyleSanitizerPipe {
    /**
     * @param {?} domSanitizer
     */
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        if (!value) {
            return value;
        }
        return this.domSanitizer.bypassSecurityTrustStyle(value);
    }
}
StyleSanitizerPipe.decorators = [
    { type: Pipe, args: [{
                name: 'styleSanitizer'
            },] },
];
/** @nocollapse */
StyleSanitizerPipe.ctorParameters = () => [
    { type: DomSanitizer, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const HOURS = 12;
class NgxMaterialTimepickerHoursFaceComponent {
    constructor() {
        this.hoursList = [];
        this.hourChange = new EventEmitter();
        this.hourSelected = new EventEmitter();
        const /** @type {?} */ angleStep = 360 / HOURS;
        this.hoursList = Array(HOURS).fill(1).map((v, i) => {
            return { time: v + i, angle: angleStep * (v + i) };
        });
    }
    /**
     * @return {?}
     */
    onClick() {
        this.hourSelected.next();
    }
}
NgxMaterialTimepickerHoursFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-hours-face',
                template: `<ngx-material-timepicker-face [selectedTime]="selectedHour" [faceTime]="hoursList"
                              (timeChange)="hourChange.next($event)"></ngx-material-timepicker-face>
`
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerHoursFaceComponent.ctorParameters = () => [];
NgxMaterialTimepickerHoursFaceComponent.propDecorators = {
    "selectedHour": [{ type: Input },],
    "hourChange": [{ type: Output },],
    "hourSelected": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['touchend',] }, { type: HostListener, args: ['click',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MINUTES = 60;
class NgxMaterialTimepickerMinutesFaceComponent {
    constructor() {
        this.minutesList = [];
        this.timeUnit = TimeUnit;
        this.minuteChange = new EventEmitter();
        const /** @type {?} */ angleStep = 360 / MINUTES;
        this.minutesList = Array(MINUTES).fill(0).map((v, i) => {
            const /** @type {?} */ index = (v + i);
            const /** @type {?} */ angle = angleStep * index;
            return { time: index === 0 ? '00' : index, angle: angle !== 0 ? angle : 360 };
        });
    }
}
NgxMaterialTimepickerMinutesFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-minutes-face',
                template: `<ngx-material-timepicker-face [faceTime]="minutesList" [selectedTime]="selectedMinute"
                              (timeChange)="minuteChange.next($event)" [unit]="timeUnit.MINUTE"></ngx-material-timepicker-face>
`
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerMinutesFaceComponent.ctorParameters = () => [];
NgxMaterialTimepickerMinutesFaceComponent.propDecorators = {
    "selectedMinute": [{ type: Input },],
    "minuteChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerFaceComponent {
    constructor() {
        this.timeUnit = TimeUnit;
        this.timeChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setClockHandPosition();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes && changes['selectedTime'].currentValue) {
            this.selectedTime = this.faceTime.find(time => time.time === changes['selectedTime'].currentValue.time);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMousedown(e) {
        e.preventDefault();
        this.isStarted = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    selectTime(e) {
        if (!this.isStarted && (e instanceof MouseEvent && e.type !== 'click')) {
            return;
        }
        const /** @type {?} */ clockFaceCords = this.clockFace.nativeElement.getBoundingClientRect();
        //Get x0 and y0 of the circle
        const /** @type {?} */ centerX = clockFaceCords.left + clockFaceCords.width / 2;
        const /** @type {?} */ centerY = clockFaceCords.top + clockFaceCords.height / 2;
        //Counting the arctangent and convert it to from radian to deg
        const /** @type {?} */ arctangent = Math.atan(Math.abs(e.clientX - centerX) / Math.abs(e.clientY - centerY)) * 180 / Math.PI;
        //Get angle according to quadrant
        const /** @type {?} */ circleAngle = countAngleByCords(centerX, centerY, e.clientX, e.clientY, arctangent);
        //Round angle according to angle step
        const /** @type {?} */ roundedAngle = roundAngle(circleAngle, 360 / this.faceTime.length);
        const /** @type {?} */ selectedTime = this.faceTime.find(val => val.angle === roundedAngle);
        this.clockHand.nativeElement.style.transform = `rotate(${roundedAngle}deg)`;
        this.timeChange.next(selectedTime);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseup(e) {
        e.preventDefault();
        this.isStarted = false;
    }
    /**
     * @return {?}
     */
    setClockHandPosition() {
        this.clockHand.nativeElement.style.transform = `rotate(${this.selectedTime.angle}deg)`;
    }
}
NgxMaterialTimepickerFaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-face',
                template: `<div class="clock-face" #clockFace>
  <div *ngIf="unit !== timeUnit.MINUTE;else minutesFace" class="clock-face__container">
    <div class="clock-face__number"
         [style.transform]="'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer"
         *ngFor="let time of faceTime">
			<span [style.transform]="'rotateZ(-'+ time.angle +'deg)' | styleSanitizer"
            [ngClass]="{'active': time.time === (selectedTime.time)}">{{time.time}}</span>
    </div>
  </div>
  <span class="clock-face__clock-hand" [ngClass]="{'clock-face__clock-hand_minute': unit === timeUnit.MINUTE}"
        #clockHand></span>
</div>
<ng-template #minutesFace>
  <div class="clock-face__container">
    <div class="clock-face__number"
         [style.transform]="'rotateZ('+ time.angle +'deg) translateX(-50%)' | styleSanitizer"
         *ngFor="let time of faceTime">
	<span [style.transform]="'rotateZ(-'+ time.angle +'deg)' | styleSanitizer"
        [ngClass]="{'active': (selectedTime.time === time.time) && time.time % 5 === 0}">
	{{time.time % 5 === 0 ? time.time : ''}}</span>
    </div>
  </div>
</ng-template>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.clock-face{width:290px;height:290px;border-radius:50%;background-color:#f0f0f0;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:20px;-webkit-box-sizing:border-box;box-sizing:border-box}.clock-face__container{margin-left:-2px}.clock-face__number{position:absolute;font-size:16px;color:grey;-webkit-transform-origin:0 100%;transform-origin:0 100%;height:calc(290px / 2 - 20px);width:50px;text-align:center;z-index:2}.clock-face__number>span{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:30px;height:30px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:auto;border-radius:50%;font-weight:500;font-family:Roboto,sans-serif}.clock-face__number>span.active{background-color:#00bfff;color:#fff}.clock-face__clock-hand{display:block;height:110px;width:2px;background-color:#00bfff;-webkit-transform-origin:0 100%;transform-origin:0 100%;position:absolute;top:calc(50% - 110px);z-index:1}.clock-face__clock-hand:after{content:'';width:7px;height:7px;border-radius:50%;background-color:#00bfff;position:absolute;bottom:-3px;left:-3.5px}.clock-face__clock-hand_minute:before{content:'';width:7px;height:7px;background-color:#fff;border:4px solid #00bfff;border-radius:50%;position:absolute;top:-3px;left:calc(50% - 8px);-webkit-box-sizing:content-box;box-sizing:content-box}@media (max-width:1023px) and (orientation:landscape){.clock-face{width:225px;height:225px;padding:5px}.clock-face__number{height:calc(225px / 2 - 5px)}.clock-face__clock-hand{height:90px;top:calc(50% - 90px)}}`]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerFaceComponent.ctorParameters = () => [];
NgxMaterialTimepickerFaceComponent.propDecorators = {
    "faceTime": [{ type: Input },],
    "selectedTime": [{ type: Input },],
    "unit": [{ type: Input },],
    "timeChange": [{ type: Output },],
    "clockFace": [{ type: ViewChild, args: ['clockFace',] },],
    "clockHand": [{ type: ViewChild, args: ['clockHand',] },],
    "onMousedown": [{ type: HostListener, args: ['touchstart', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] },],
    "selectTime": [{ type: HostListener, args: ['click', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event.changedTouches[0]'],] }, { type: HostListener, args: ['touchend', ['$event.changedTouches[0]'],] }, { type: HostListener, args: ['mousemove', ['$event'],] },],
    "onMouseup": [{ type: HostListener, args: ['touchend', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] },],
};
/**
 * @param {?} angle
 * @param {?} step
 * @return {?}
 */
function roundAngle(angle, step) {
    const /** @type {?} */ roundedAngle = Math.round(angle / step) * step;
    return roundedAngle === 0 ? 360 : roundedAngle;
}
/**
 * @param {?} x0
 * @param {?} y0
 * @param {?} x
 * @param {?} y
 * @param {?} currentAngle
 * @return {?}
 */
function countAngleByCords(x0, y0, x, y, currentAngle) {
    if (y > y0 && x >= x0) {
        return 180 - currentAngle;
    }
    else if (y > y0 && x < x0) {
        return 180 + currentAngle;
    }
    else if (y < y0 && x < x0) {
        return 360 - currentAngle;
    }
    else {
        return currentAngle;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TimeFormatterPipe {
    /**
     * @param {?} time
     * @param {?} timeUnit
     * @return {?}
     */
    transform(time, timeUnit) {
        if (!time) {
            return time;
        }
        switch (timeUnit) {
            case TimeUnit.HOUR:
                return utc(time * 3600 * 1000).format('HH');
            case TimeUnit.MINUTE:
                return utc(time * 60 * 1000).format('mm');
        }
    }
}
TimeFormatterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'timeFormatter'
            },] },
];
/** @nocollapse */
TimeFormatterPipe.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerButtonComponent {
}
NgxMaterialTimepickerButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-material-timepicker-button',
                template: `<button class="timepicker-button" type="button">
  <span><ng-content></ng-content></span>
</button>
`,
                styles: [`@import url(https://fonts.googleapis.com/css?family=Roboto:400,500,700);.timepicker-button{display:inline-block;height:36px;min-width:88px;line-height:36px;border:12px;border-radius:2px;background-color:transparent;color:#00bfff;text-align:center;-webkit-transition:all 450ms cubic-bezier(.23,1,.32,1);transition:all 450ms cubic-bezier(.23,1,.32,1);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;cursor:pointer;outline:0}.timepicker-button:focus,.timepicker-button:hover{background-color:rgba(153,153,153,.2)}.timepicker-button>span{font-size:14px;text-transform:uppercase;font-weight:600;padding-left:16px;padding-right:16px;font-family:Roboto,sans-serif}`]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerButtonComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
//Workaround for error "Cannot call a namespace ('moment')
const moment$2 = moment;
const VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimepickerDirective),
    multi: true
};
class TimepickerDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onTouched = () => {
        };
        this.onChange = () => {
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        this._format = value === 24 ? TimeFormat.TWENTY_FOUR : TimeFormat.TWELVE;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = formatTime(value, this._format);
        this.elementRef.nativeElement.value = value ? formatTime(value, this._format) : '';
        this.timepicker.setDefaultTime(formatTime(value));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.timepicker) {
            this.timepickerSubscription = this.timepicker.timeSet.subscribe((time) => {
                this.value = time;
                this.onChange(time);
                this.onTouched();
            });
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onInput(value) {
        this._value = value;
        this.onChange(value);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.timepicker.open();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.timepickerSubscription.unsubscribe();
    }
}
TimepickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxTimepicker]',
                providers: [VALUE_ACCESSOR],
                host: {
                    '[disabled]': 'disabled',
                    '(input)': 'onInput($event.target.value)',
                    '(blur)': 'onTouched()',
                }
            },] },
];
/** @nocollapse */
TimepickerDirective.ctorParameters = () => [
    { type: ElementRef, },
];
TimepickerDirective.propDecorators = {
    "timepicker": [{ type: Input, args: ['ngxTimepicker',] },],
    "disabled": [{ type: Input },],
    "format": [{ type: Input },],
    "value": [{ type: Input },],
    "onClick": [{ type: HostListener, args: ['click',] },],
};
/**
 * @param {?} time
 * @param {?=} format
 * @return {?}
 */
function formatTime(time, format = TimeFormat.TWELVE) {
    return moment$2(time, format).format(format);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class OverlayDirective {
    /**
     * @param {?} eventService
     */
    constructor(eventService) {
        this.eventService = eventService;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        this.eventService.backdropClickSubject.next(e);
        e.preventDefault();
    }
}
OverlayDirective.decorators = [
    { type: Directive, args: [{
                selector: '[overlay]'
            },] },
];
/** @nocollapse */
OverlayDirective.ctorParameters = () => [
    { type: NgxMaterialTimepickerEventService, },
];
OverlayDirective.propDecorators = {
    "onClick": [{ type: HostListener, args: ['click', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class FocusAnchorDirective {
    /**
     * @param {?} document
     * @param {?} elementRef
     */
    constructor(document, elementRef) {
        this.document = document;
        this.element = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.activeElement = /** @type {?} */ (this.document.activeElement);
        // To avoid an error ExpressionChangedAfterItHasBeenCheckedError
        setTimeout(() => this.element.focus());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.activeElement.focus();
    }
}
FocusAnchorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[focusAnchor]'
            },] },
];
/** @nocollapse */
FocusAnchorDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] },] },
    { type: ElementRef, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxMaterialTimepickerModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxMaterialTimepickerModule,
            providers: [NgxMaterialTimepickerService, NgxMaterialTimepickerEventService]
        };
    }
}
NgxMaterialTimepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                exports: [
                    NgxMaterialTimepickerComponent,
                    TimepickerDirective
                ],
                declarations: [
                    NgxMaterialTimepickerComponent,
                    StyleSanitizerPipe,
                    NgxMaterialTimepickerHoursFaceComponent,
                    NgxMaterialTimepickerMinutesFaceComponent,
                    NgxMaterialTimepickerFaceComponent,
                    TimeFormatterPipe,
                    NgxMaterialTimepickerButtonComponent,
                    TimepickerDirective,
                    OverlayDirective,
                    FocusAnchorDirective,
                ]
            },] },
];
/** @nocollapse */
NgxMaterialTimepickerModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxMaterialTimepickerModule, NgxMaterialTimepickerButtonComponent as ɵk, NgxMaterialTimepickerFaceComponent as ɵi, NgxMaterialTimepickerHoursFaceComponent as ɵg, NgxMaterialTimepickerMinutesFaceComponent as ɵh, FocusAnchorDirective as ɵm, TimepickerDirective as ɵe, OverlayDirective as ɵl, AnimationState as ɵa, NgxMaterialTimepickerComponent as ɵb, StyleSanitizerPipe as ɵf, TimeFormatterPipe as ɵj, NgxMaterialTimepickerEventService as ɵd, NgxMaterialTimepickerService as ɵc };
//# sourceMappingURL=ngx-material-timepicker.js.map
